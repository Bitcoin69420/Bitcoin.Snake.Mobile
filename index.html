<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Bitcoin Snake Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"> <!-- Mobile viewport -->
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { border: 2px solid #fff; background: #111; touch-action: none; } /* Prevent touch interference */
        #startScreen, #gameOverScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; font-family: Arial, sans-serif; z-index: 10; transition: opacity 0.5s ease-in; }
        #startScreen h1, #gameOverScreen h1 { font-size: 48px; color: orange; }
        #startScreen p, #gameOverScreen p { font-size: 24px; }
        #startScreen span, #gameOverScreen span { font-size: 18px; margin-top: 20px; }
        #gameOverScreen { opacity: 0; } /* For fade-in */
        #gameOverScreen.visible { opacity: 1; }
        @media (max-width: 600px) { /* Mobile adjustments */
            canvas { width: 100%; height: auto; }
            #startScreen h1, #gameOverScreen h1 { font-size: 36px; }
            #startScreen p, #gameOverScreen p { font-size: 18px; }
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>Bitcoin.Snake</h1>
        <p></p>
        <span>Press any key or tap to start</span>
    </div>
    <div id="gameOverScreen">
        <h1>Game Over!</h1>
        <p id="finalScore">Score: 0</p>
        <p>made by B.W.</p>
        <span>Press any key or tap to restart</span>
    </div>
    <canvas id="gameCanvas"></canvas> <!-- Width/height set in JS for responsiveness -->
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreText = document.getElementById('finalScore');

        // Responsive canvas setup
        let canvasSize = Math.min(window.innerWidth, window.innerHeight) * 0.9; // Fit to screen
        canvas.width = canvasSize;
        canvas.height = canvasSize;
        const gridSize = canvasSize / 20; // Dynamic grid based on canvas size

        // Game variables
        let snake = [{ x: canvas.width / 2, y: canvas.height / 2 }];
        let dx = gridSize;
        let dy = 0;
        let food = { x: 0, y: 0 };
        let score = 0;
        let speed = /Mobi|Tablet|Android|iPad|iPhone/.test(navigator.userAgent) ? 250 : 200; // Slower on mobile
        let gameLoop;
        const currencies = ['$', '€', '¥', '¥', 'Rp', 'د.إ', '₽']; // Fallback symbols

        // Currency bill images (URLs to public domain images; replace with your own if needed)
        const currencyImages = [
            { symbol: '$', img: new Image(), url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/9/96/Obverse_of_the_Series_2009_%24100_Federal_Reserve_Note.jpg/320px-Obverse_of_the_Series_2009_%24100_Federal_Reserve_Note.jpg' }, // Dollar
            { symbol: '€', img: new Image(), url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Euro_banknotes_2015.png/320px-Euro_banknotes_2015.png' }, // Euro (using a sample; adjust for specific bill)
            { symbol: '¥', img: new Image(), url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/3/3f/1000_yen_banknote_2004_series.jpg/320px-1000_yen_banknote_2004_series.jpg' }, // Yen
            { symbol: '¥', img: new Image(), url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/3/3b/100_Renminbi_note_obverse.jpg/320px-100_Renminbi_note_obverse.jpg' }, // Yuan
            { symbol: 'Rp', img: new Image(), url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/Indonesia_100000_rupiah_2016_obverse.jpg/320px-Indonesia_100000_rupiah_2016_obverse.jpg' }, // Rupiah
            { symbol: 'د.إ', img: new Image(), url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/100_AED_obverse.jpg/320px-100_AED_obverse.jpg' }, // Dirhams
            { symbol: '₽', img: new Image(), url: 'https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/1000_russian_rubles_2017_obverse.jpg/320px-1000_russian_rubles_2017_obverse.jpg' } // Rubles
        ];

        // Preload images
        currencyImages.forEach(item => {
            item.img.src = item.url;
        });

        let currentFoodImage = null; // Will hold the selected image object

        // Bitcoin price ticker
        let btcPrice = 'Loading...';
        async function fetchBtcPrice() {
            try {
                const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd');
                const data = await response.json();
                btcPrice = data.bitcoin.usd.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            } catch (error) {
                btcPrice = 'Loading...';
            }
        }

        // Background particles (less busy, more modern)
        const particles = [];
        for (let i = 0; i < 30; i++) {
            particles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 1.5, // Slower speed
                vy: (Math.random() - 0.5) * 1.5,
                size: Math.random() * 3 + 1,
                color: `rgba(${Math.floor(Math.random() * 30) + 200}, ${Math.floor(Math.random() * 50) + 100}, 0, ${Math.random() * 0.3 + 0.2})` // Subdued glow
            });
        }

        // Fireworks (only on score)
        let fireworks = [];
        function createFirework(x, y) {
            const fireworkParticles = [];
            for (let i = 0; i < 15; i++) { // Fewer particles
                fireworkParticles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    size: Math.random() * 2 + 1,
                    color: ['orange', 'gold', 'white'][Math.floor(Math.random() * 3)],
                    life: 20 + Math.random() * 10 // Shorter life for less busyness
                });
            }
            fireworks.push({ particles: fireworkParticles });
        }

        function updateFireworks() {
            fireworks = fireworks.filter(fw => fw.particles.length > 0);
            fireworks.forEach(fw => {
                fw.particles.forEach((p, index) => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.05; // Gentle gravity
                    p.life--;
                    if (p.life <= 0) fw.particles.splice(index, 1);
                });
            });
        }

        function drawFireworks() {
            fireworks.forEach(fw => {
                fw.particles.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();
                });
            });
        }

        // Bitcoin-style maze (minimalist background lines)
        function drawMaze() {
            ctx.strokeStyle = 'rgba(255, 165, 0, 0.2)'; // Very faint
            ctx.lineWidth = 1;

            // Simple grid with fewer connections for modern look
            for (let x = 0; x < canvas.width; x += gridSize * 4) { // Wider spacing
                for (let y = 0; y < canvas.height; y += gridSize * 4) {
                    // Horizontal lines
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + gridSize * 4, y);
                    ctx.stroke();

                    // Vertical lines
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, y + gridSize * 4);
                    ctx.stroke();

                    // Occasional diagonal for subtle depth
                    if (Math.random() > 0.8) {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + gridSize * 2, y + gridSize * 2);
                        ctx.stroke();
                    }
                }
            }
        }

        // Moon and orbiting rocket
        const moon = {
            x: canvas.width / 2,
            y: canvas.height - 50 - 20, // Bottom center with padding (y=330 for 400px height)
            radius: 125
        };
        let rocketAngle = Math.PI + Math.PI / 4; // Start from top left (approx 225 degrees)

        function drawMoon() {
            // Moon body
            ctx.beginPath();
            ctx.arc(moon.x, moon.y, moon.radius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(200, 200, 200, 0.3)'; // Semi-transparent gray
            ctx.fill();

            // Simple craters
            ctx.beginPath();
            ctx.arc(moon.x - 15, moon.y - 10, 10, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(150, 150, 150, 0.3)';
            ctx.fill();
            ctx.beginPath();
            ctx.arc(moon.x + 20, moon.y + 5, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(moon.x - 5, moon.y + 20, 6, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawRocket() {
            // Update angle for slow orbit
            rocketAngle += 0.015; // Slightly faster for better motion

            // Elliptical orbit (wider horizontally to "pass over" the moon) - adjusted for bottom position
            const orbitRadiusX = moon.radius + 130; // Slightly increased for space
            const orbitRadiusY = moon.radius + 65; // Slightly increased
            const rocketX = moon.x + Math.cos(rocketAngle) * orbitRadiusX;
            const rocketY = moon.y + Math.sin(rocketAngle) * orbitRadiusY;

            // Calculate rotation angle based on direction (tangent to path)
            const rotation = Math.atan2(Math.sin(rocketAngle) * orbitRadiusY, Math.cos(rocketAngle) * orbitRadiusX) + Math.PI / 2;

            // Save context and translate/rotate for rocket drawing
            ctx.save();
            ctx.translate(rocketX, rocketY);
            ctx.rotate(rotation);

            // Rocket body (cylinder-like) - scaled 3x
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; // White body, semi-transparent
            ctx.fillRect(-15, -60, 30, 75); // Scaled from (-5, -20, 10, 25)

            // Nose cone - scaled 3x
            ctx.beginPath();
            ctx.moveTo(-15, -60);
            ctx.lineTo(15, -60);
            ctx.lineTo(0, -90); // Scaled from (0, -30)
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; // Red nose
            ctx.fill();

            // Fins - scaled 3x
            ctx.beginPath();
            ctx.moveTo(-15, 15); // Scaled from (-5, 5)
            ctx.lineTo(-30, 30); // Scaled from (-10, 10)
            ctx.lineTo(-15, 15);
            ctx.fillStyle = 'rgba(0, 0, 255, 0.5)'; // Blue fins
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(15, 15); // Scaled from (5, 5)
            ctx.lineTo(30, 30); // Scaled from (10, 10)
            ctx.lineTo(15, 15);
            ctx.fill();

            // Bitcoin symbol on body - scaled 3x
            ctx.fillStyle = 'orange';
            ctx.font = 'bold 36px Arial'; // Scaled from 12px
            ctx.fillText('₿', -15, -15); // Adjusted position (scaled from (-5, -5))

            // Exhaust flames (flickering) - scaled 3x
            const flameSize = Math.random() * 15 + 15; // Scaled random flicker (from 5+5)
            ctx.beginPath();
            ctx.moveTo(-9, 15); // Scaled from (-3,5)
            ctx.lineTo(9, 15); // Scaled from (3,5)
            ctx.lineTo(0, 15 + flameSize);
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 165, 0, 0.7)'; // Orange flame
            ctx.fill();

            ctx.restore(); // Restore context
        }

        function generateFood() {
            food.x = Math.floor(Math.random() * (canvas.width / gridSize)) * gridSize;
            food.y = Math.floor(Math.random() * (canvas.height / gridSize)) * gridSize;
            currentFoodImage = currencyImages[Math.floor(Math.random() * currencyImages.length)];
        }

        function drawBackground() {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw maze for subtle depth
            //drawMaze();

            // Draw moon
            drawMoon();

            // Draw rocket (over the moon for "traveling over" effect)
            drawRocket();

            // Animate particles (calmer)
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
                if (p.y < 0 || p.y > canvas.height) p.vy *= -1;
                // Rare direction change
                if (Math.random() < 0.005) {
                    p.vx = (Math.random() - 0.5) * 1.5;
                    p.vy = (Math.random() - 0.5) * 1.5;
                }

                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.fill();
            });

            // Draw fireworks
            updateFireworks();
            drawFireworks();
        }

        function drawSnake() {
            // Add glow effect for all segments
            ctx.shadowColor = 'orange';
            ctx.shadowBlur = 10;

            snake.forEach((segment, index) => {
                const x = segment.x;
                const y = segment.y;

                if (index === 0) {
                    // Cooler head: Elliptical with gradient and bolder symbol
                    const gradient = ctx.createLinearGradient(x, y, x + gridSize, y + gridSize);
                    gradient.addColorStop(0, 'orange');
                    gradient.addColorStop(1, 'gold');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.ellipse(x + gridSize / 2, y + gridSize / 2, gridSize / 1.5, gridSize / 2, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Bolder Bitcoin symbol with shine
                    ctx.fillStyle = 'black';
                    ctx.font = 'bold 18px Arial';
                    ctx.fillText('₿', x + 2, y + 16);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'; // Shine highlight
                    ctx.fillText('₿', x + 1, y + 15);
                } else {
                    // Cooler body: Rounded "block" with gradient and small symbol
                    const gradient = ctx.createLinearGradient(x, y, x + gridSize, y + gridSize);
                    gradient.addColorStop(0, 'darkorange');
                    gradient.addColorStop(1, 'orange');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.roundRect(x + 2, y + 2, gridSize - 4, gridSize - 4, 5); // Rounded rectangle
                    ctx.fill();

                    // Small faint Bitcoin symbol on each segment
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.font = 'bold 10px Arial';
                    ctx.fillText('₿', x + 5, y + 14);

                    // Connect to previous segment for chain effect
                    if (index > 0) {
                        const prev = snake[index - 1];
                        ctx.beginPath();
                        ctx.moveTo(x + gridSize / 2, y + gridSize / 2);
                        ctx.lineTo(prev.x + gridSize / 2, prev.y + gridSize / 2);
                        ctx.strokeStyle = 'darkorange';
                        ctx.lineWidth = 4;
                        ctx.stroke();
                    }
                }
            });

            // Reset shadow after drawing snake
            ctx.shadowBlur = 0;
        }

        function drawFood() {
            if (currentFoodImage && currentFoodImage.img.complete && currentFoodImage.img.naturalWidth !== 0) {
                // Draw bill image, scaled to gridSize with random rotation
                ctx.save();
                ctx.translate(food.x + gridSize / 2, food.y + gridSize / 2);
                ctx.rotate((Math.random() * 20 - 10) * Math.PI / 180); // Slight random rotation
                ctx.drawImage(currentFoodImage.img, -gridSize / 2, -gridSize / 2, gridSize, gridSize);
                ctx.restore();
            } else {
                // Fallback to text if image not loaded
                ctx.fillStyle = 'green';
                ctx.font = 'bold 20px Arial';
                ctx.fillText(currentFoodImage.symbol, food.x, food.y + gridSize);
            }
        }

        function drawScore() {
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.fillText(`Score: ${score}`, canvas.width - 100, 20);
        }

        function drawBtcTicker() {
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.fillText(`BTC: $${btcPrice}`, 10, canvas.height - 10);
        }

        function moveSnake() {
            let head = { x: snake[0].x + dx, y: snake[0].y + dy };

            // Wrap around edges (pass through walls)
            if (head.x >= canvas.width) head.x = 0;
            if (head.x < 0) head.x = canvas.width - gridSize;
            if (head.y >= canvas.height) head.y = 0;
            if (head.y < 0) head.y = canvas.height - gridSize;

            // Self collision
            let collided = false;
            snake.forEach(segment => {
                if (segment.x === head.x && segment.y === head.y) {
                    collided = true;
                }
            });
            if (collided) {
                gameOver();
                return;
            }

            snake.unshift(head);

            // Check for food collision
            if (head.x === food.x && head.y === food.y) {
                score++;
                speed = Math.max(50, speed - 10); // Increase speed gradually
                createFirework(food.x, food.y); // Firework on score
                generateFood();
            } else {
                snake.pop(); // Remove tail unless food eaten
            }
        }

        function gameOver() {
            clearInterval(gameLoop);
            clearInterval(priceInterval);
            finalScoreText.textContent = `Score: ${score}`;
            gameOverScreen.classList.add('visible');
            gameOverScreen.style.display = 'flex';
        }

        function resetGame() {
            snake = [{ x: canvas.width / 2, y: canvas.height / 2 }];
            dx = gridSize;
            dy = 0;
            score = 0;
            speed = /Mobi|Tablet|Android|iPad|iPhone/.test(navigator.userAgent) ? 250 : 200;
            fireworks = [];
            rocketAngle = Math.PI + Math.PI / 4; // Reset to top-left start
            generateFood();
            fetchBtcPrice(); // Initial fetch on reset
            priceInterval = setInterval(fetchBtcPrice, 10000);
            gameOverScreen.style.display = 'none';
            update(); // Initial draw
            gameLoop = setInterval(update, speed);
        }

        function update() {
            drawBackground();
            moveSnake();
            drawSnake();
            drawFood();
            drawScore();
            drawBtcTicker();
        }

        // Touch controls for mobile
        let touchStartX = 0;
        let touchStartY = 0;
        canvas.addEventListener('touchstart', e => {
            if (startScreen.style.display !== 'none') {
                startScreen.style.display = 'none';
                generateFood();
                fetchBtcPrice();
                priceInterval = setInterval(fetchBtcPrice, 10000);
                update();
                gameLoop = setInterval(update, speed);
                return;
            } else if (gameOverScreen.style.display !== 'none') {
                resetGame();
                return;
            }
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        });

        canvas.addEventListener('touchmove', e => {
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                const deltaX = touch.clientX - touchStartX;
                const deltaY = touch.clientY - touchStartY;
                const minSwipe = 50; // Minimum distance for swipe detection

                if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipe) {
                    // Horizontal swipe
                    if (deltaX > 0 && dx === 0) { dx = gridSize; dy = 0; } // Right
                    else if (deltaX < 0 && dx === 0) { dx = -gridSize; dy = 0; } // Left
                } else if (Math.abs(deltaY) > Math.abs(deltaX) && Math.abs(deltaY) > minSwipe) {
                    // Vertical swipe
                    if (deltaY > 0 && dy === 0) { dx = 0; dy = gridSize; } // Down
                    else if (deltaY < 0 && dy === 0) { dx = 0; dy = -gridSize; } // Up
                }
                e.preventDefault(); // Prevent scrolling/zoom
            }
        });

        // Keyboard controls for desktop (unchanged)
        document.addEventListener('keydown', e => {
            if (startScreen.style.display !== 'none') {
                startScreen.style.display = 'none';
                generateFood();
                fetchBtcPrice();
                priceInterval = setInterval(fetchBtcPrice, 10000);
                update();
                gameLoop = setInterval(update, speed);
            } else if (gameOverScreen.style.display !== 'none') {
                resetGame();
            } else {
                if (e.key === 'ArrowUp' && dy === 0) { dx = 0; dy = -gridSize; }
                if (e.key === 'ArrowDown' && dy === 0) { dx = 0; dy = gridSize; }
                if (e.key === 'ArrowLeft' && dx === 0) { dx = -gridSize; dy = 0; }
                if (e.key === 'ArrowRight' && dx === 0) { dx = gridSize; dy = 0; }
            }
        });

        // Handle resize/orientation change for responsiveness
        window.addEventListener('resize', () => {
            canvasSize = Math.min(window.innerWidth, window.innerHeight) * 0.9;
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            // Re-center snake and food if needed (optional; current positions may shift slightly)
        });

        // Initial setup (draw background on title screen)
        drawBackground();
        generateFood(); // Initial food generation for preload
    </script>
</body>
</html>